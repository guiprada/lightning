
*- remove nill, after adding an Option type
- remove exceptions
- add become for tail call optimization.
- add nuple (n tuple) type(leveraging roslyn to compile runtime generated UnitTypes), array based.
- add nuple based structs.
- destructuring
- add typed functions and interfaces - non typed functions are total functions and should be flagged by the compiler.
	- variables to typed functions should not need type checking by the runtime - compiler enforced
- add pattern matching.
- add concurrency support (yield or await - check non coloring goroutines)
- add non blocking new thread

- solve table-list and supertable mess. Keep in mind that language should be simple and not high performance, at this point. Perhaps replace metatables with non recurring
	dispatching tables, with autoflatten logic.
- Create object UnitType, as an all pvt attributes, message only table,
	create actor as a object with update hooks.
- Add logic to avoid roslyn and lighting recompilation - timestamp based - perhaps server based
- Verify Garbage collection and Env for memory leaks.
- verify formal language definition.
- verify multicore implementation.
- add some form of varargs, probably from receing an ENV as argument , ... and unpack(lua 5.1 style).
- modify to be strongly typed  single assignment, can we flag side effects? perhaps with enforced #!_ naming convention or make them explicitly manipulate a ENV variable
- vm as first class, env as first class, UnitType as first class
	- environment should be a nuple, nuple struct, a list or a table, comming in mutable and imutable variations.
- define type partially evaluated, add currying. Perhaps use env or an attribute of function objects.

- compile time checks
- core pause on error
- core dump and reload
- hybrid core paused with timeout to dump
- core dump merge :)

- try to run in blazor.
- native dll to be embedded in any language with ffi
- freeze language and create a tutorial and programming manual.
- Create object UnitType, as an all pvt attributes, message only table,
	- create actor as a object with update hooks.
- restore backpack monogame bindings, or perhaps use raylib for graphical bootstrap or even an html canvas :)
	- perhaps a ffi and love2d port

by now we should learn roslyn
- convert some of the prelude to c# generated by lightning to test metaprogramming c#, write lightning metaplagramming function(METHODS FOR creating functions and and adding operations), add way to create, introspect and manipulate c# classes.
	read -> .NET Development Using the Compiler API
- Add proper dynamic code generation and loading
	read ->Faster than C#: efficient implementation of dynamic
languages on .NET?
	Expert .NET 2.0 IL Assembler
	Pro DLR in .NET 4
	Dynamic Language Runtime
	The IL Assembly Language Programmers? Reference
	.Net il assembler
	Roslyn cookbook, manish vasani
	inside .net il assembler
- benchmark performance for main() as dynamicaly generated c# calling X native c#.
- Test F# metaprogramming.
       https://www.jamesdrandall.com/posts/compiling_and_executing_fsharp_dynamically_at_runtime/
- add jit to CIL :)

- implement compiler in lightning using SExpr as ast
- implement weakly typed dynamic lisp compiler, lisp is ast
- implement smalltalk compiler
- implement prolog compiler
- implement js compiler
- create lisp math expression evaluator
- implement infered and optionally typed lisp compiler, lisp is ast
- port to web, with Dom manipulation.
- implement compiler optimizations.https://www.ocamlwiki.com/wiki/Bytecode_Optimization_in_OCaml
	Instruction Selection and Scheduling
		Instruction selection and scheduling are essential steps in bytecode optimization. This process involves
		choosing the most efficient bytecode instructions and arranging them in a way that minimizes execution time and resource usage.
	Constant Folding and Propagation
		Constant folding and propagation eliminate unnecessary computations by replacing expressions involving
		constants with the resulting constant value. This optimization reduces redundant calculations and improves
		the overall efficiency of the bytecode.
	Dead Code Elimination
		Dead code elimination identifies and removes portions of the bytecode that are unreachable or do not contribute to the final
		program output. This optimization reduces the size of the bytecode and improves execution speed by eliminating unnecessary computations.
	Inlining
		Inlining is a technique that replaces function calls with the actual function body. This optimization eliminates the overhead associated with
		function call instructions and improves performance by reducing the number of instructions executed.
	Loop Optimization
		Loop optimization techniques aim to improve the execution speed of loops within the bytecode. These techniques include loop unrolling, loop
		fusion, loop interchange, and loop invariant code motion. By optimizing loops, the bytecode can execute more efficiently and achieve better
		performance.
	Garbage Collection Optimization
		Garbage collection optimization techniques focus on managing memory allocation and deallocation efficiently. By improving garbage collection,
		the bytecode can minimize memory fragmentation and reduce the frequency of garbage collection sweeps, resulting in improved overall performance.
	Benefits
	Bytecode optimization in OCaml provides several benefits, including:
		- Improved execution speed and reduced program latency.
		- Reduced memory consumption and efficient memory management.
		- Enhanced performance of OCaml programs running on multiple platforms.
		- Increased efficiency of the bytecode, resulting in faster program execution.

- c# interpreter optimizations
- code clean_up
- add native code generating capabilities.
- add wasm generating capabilities.
- add dynamic code loading.
- add support for metaprogramming il and assembly.
- write interpreter in lighting and bootstrap it.
- add debugger and live Env introspector and editor?.
- write an gpgpu based json object database.
- port a graphics library and the extinction 5 game
- create a language server for vscode and neovim
- create c# bindgen
- integrate with nugget
- study ocaml type system implementation, Hindley-Milner
	https://github.com/tomprimozic/type-systems
