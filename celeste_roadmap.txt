
			we are slow, but have some tricks
			we are simple but many

- Iniciar blog tutorial.
- Registrar dominio celeste.org e registrar o nome intuição eletrica.
- Abrir empresa

- Test and fix logger
- Split prelude

- try to run in blazor.
- solve table-list and supertable mess. Keep in mind that language should be simple and not high performance, at this point. Perhaps replace metatables with non recurring dispatching tables, with autoflatten logic. Create object as all pvt attributes, message only table, create actor as a object with programable update hooks.
- Verify Garbage collection and Env for memory leaks.
- verify formal language definition.
- verify multicore implementation.
- code clean up.
- remove nill and exceptions, after adding an Option type
- add yield for coroutines and become for tail call optimization.
-  add some form of varargs, probably from receing an ENV as argument , ... and unpack(lua 5.1 style).
- modify to be strongly typed  single assignment, can we flag side effects, perhaps with enforced #!_ naming convention or make them explicitly manipulate a ENV variable
- vm as first class, env as first class - environment should be a nuple, nuple struct, a list or a table, comming in mutable and imutable variations.
- add nuple (n tuple) type( adding typeclasses on the fly), array based.
- add nuple based structs.
- add pattern matching.
- define type partially evaluated, add currying. Perhaps use env or an attribute of function objects.
- freeze language and create a tutorial and programming manual.
- restore backpack monogame bindings, or perhaps use raylib for graphical bootstrap


by now we should learn roslyn
- convert some of the prelude to c# generated by lightning to test metaprogramming c#, write lightning metaplagramming function(METHODS FOR creating functions and and adding operations), add way to create, introspect and manipulate c# classes.
	read -> .NET Development Using the Compiler API
- Add proper dynamic code generation and loading
	read ->Faster than C#: efficient implementation of dynamic
languages on .NET?
	Expert .NET 2.0 IL Assembler
	Pro DLR in .NET 4
	Dynamic Language Runtime
	The IL Assembly Language Programmers? Reference
	.Net il assembler
	Roslyn cookbook, manish vasani
	inside .net il assembler
- benchmark performance for main() as dynamicaly generated c# calling X native c#.
- Test F# metaprogramming.
       https://www.jamesdrandall.com/posts/compiling_and_executing_fsharp_dynamically_at_runtime/

- define type partially evaluated, add currying. Perhaps use env or nuples..
- implement compiler in lightning using sexpr as ast
- implement weakly typed dynamic lisp compiler, lisp is ast
- implement smalltalk compiler
- implement prolog compiler
- implement js compiler
- create lisp math expression evaluator
- implement infered and optionally typed lisp compiler, lisp is ast
- port to web, with Dom manipulation.
- implement compiler optimizations.https://www.ocamlwiki.com/wiki/Bytecode_Optimization_in_OCaml
	Bytecode Optimization in OCaml[edit | edit source]
	Bytecode optimization in OCaml is a crucial aspect of optimizing the execution of OCaml programs compiled to bytecode. This process involves various techniques that enhance the performance and efficiency of the bytecode, resulting in improved execution speed and reduced memory consumption. Bytecode optimization plays a significant role in maximizing the benefits of using the OCaml programming language.
	Background[edit | edit source]
	OCaml is a statically typed functional programming language that provides a bytecode compiler, which translates OCaml source code into bytecode. The bytecode is then executed by the OCaml virtual machine (OCamlrun). Although the bytecode is not as fast as native machine code, it offers platform independence and enables the execution of OCaml programs on different platforms without recompilation.
	Optimization Techniques[edit | edit source]
	Several techniques are utilized to optimize OCaml bytecode and enhance its performance. These techniques focus on different aspects of the bytecode, such as reducing unnecessary overhead, improving memory management, and enhancing execution speed.
	Instruction Selection and Scheduling[edit | edit source]
	Instruction selection and scheduling are essential steps in bytecode optimization. This process involves choosing the most efficient bytecode instructions and arranging them in a way that minimizes execution time and resource usage.
	Constant Folding and Propagation[edit | edit source]
	Constant folding and propagation eliminate unnecessary computations by replacing expressions involving constants with the resulting constant value. This optimization reduces redundant calculations and improves the overall efficiency of the bytecode.
	Dead Code Elimination[edit | edit source]
	Dead code elimination identifies and removes portions of the bytecode that are unreachable or do not contribute to the final program output. This optimization reduces the size of the bytecode and improves execution speed by eliminating unnecessary computations.
	Inlining[edit | edit source]
	Inlining is a technique that replaces function calls with the actual function body. This optimization eliminates the overhead associated with function call instructions and improves performance by reducing the number of instructions executed.
	Loop Optimization[edit | edit source]
	Loop optimization techniques aim to improve the execution speed of loops within the bytecode. These techniques include loop unrolling, loop fusion, loop interchange, and loop invariant code motion. By optimizing loops, the bytecode can execute more efficiently and achieve better performance.
	Garbage Collection Optimization[edit | edit source]
	Garbage collection optimization techniques focus on managing memory allocation and deallocation efficiently. By improving garbage collection, the bytecode can minimize memory fragmentation and reduce the frequency of garbage collection sweeps, resulting in improved overall performance.
	Benefits[edit | edit source]
	Bytecode optimization in OCaml provides several benefits, including:
	- Improved execution speed and reduced program latency. - Reduced memory consumption and efficient memory management. - Enhanced performance of OCaml programs running on multiple platforms. - Increased efficiency of the bytecode, resulting in faster program execution.

- c# interpreter optimizations
- code clean_up
- read incremental aproach to compiler construction and add code generating capabilities.
- add wasm generating capabilities.
- add dynamic code loading.
- add support for metaprogramming assembly.
- write interpreter in lighting and bootstrap it.
- add debugger and live Env introspector and editor?.
- write an gpgpu based json object database.
- port a graphics library and the extinction 5 game
- create a language server for vscode and neovim
- create c# bindgen
- integrate with nugget
- study ocaml type system implementation
