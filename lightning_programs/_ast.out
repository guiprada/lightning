[PROGRAM
    [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([LITERAL "*** Welcome to lightning test suite Zzz :) ***"])]]
    [VARIABLE DECLARATION os_string = [FUNCTION CALL [VARIABLE get_os]()]]
    [VARIABLE DECLARATION os = [LITERAL "Unknown"]]
    [IF [FUNCTION CALL [VARIABLE os_string:[METHOD contains]]([LITERAL "Windows"])]
        [EXPR_STMT [ASSIGMENT os = [LITERAL "Windows"]]]
    ELSE 
        [IF [FUNCTION CALL [VARIABLE os_string:[METHOD contains]]([LITERAL "Unix"])]
            [EXPR_STMT [ASSIGMENT os = [LITERAL "Unix"]]]
        ]
    ]
    [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([FUNCTION CALL [VARIABLE get_os]()])]]
    [IF [BINARY [VARIABLE intrinsic.[IDENTIFIER create]] == [LITERAL "Null"]]
        [BLOCK
            [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([LITERAL "No inline intrinsic support!"])]]
        ]
    ]
    [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([LITERAL "-- Starting tests --"])]]
    [VARIABLE DECLARATION start_time = [FUNCTION CALL [VARIABLE time.[IDENTIFIER now]]()]]
    [VARIABLE DECLARATION _assert = [FUNCTION CALL [VARIABLE require]([LITERAL "assert.ltn"])]]
    [VARIABLE DECLARATION assert_counter = [FUNCTION CALL [VARIABLE require]([LITERAL "assert_counter.ltn"])]]
    [VARIABLE DECLARATION assert = [VARIABLE assert_counter.[IDENTIFIER assert]]]
    [VARIABLE DECLARATION assert_not = [VARIABLE assert_counter.[IDENTIFIER assert_not]]]
    [VARIABLE DECLARATION count_errors = [VARIABLE assert_counter.[IDENTIFIER get_error_counter]]]
    [VARIABLE DECLARATION clear_errors = [VARIABLE assert_counter.[IDENTIFIER reset_error_counter]]]
    [VARIABLE DECLARATION errors = [LITERAL 0]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/assert.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/numbers.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/strings.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/pmap.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/rmap.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/map.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/reduce.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/table.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/scoping.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/up_value.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/closures.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/lambdas.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/boolean.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/iterators.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/methods.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/compound_calls.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/transient.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/math.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/eval.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/maybe.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/assign_op.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/lock.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/vm_management.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/inline_intrinsics.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/nuples.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/super_table.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/char.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/integers.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/anonymous_call.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/try.ltn"])]]]
    [BLOCK
    ]
    [BLOCK
        [VARIABLE DECLARATION a_table = [LIST [LITERAL 1] : 
            [FUNCTION EXPRESSION (a)
                [RETURN [VARIABLE a]]
            ]]
        [EXPR_STMT [FUNCTION CALL [VARIABLE a_table[[VAR_EXPRESSION ]]]([BINARY [LITERAL 1] + [LITERAL 1]])]]
    ]
    [EXPR_STMT [FUNCTION CALL [VARIABLE machine.[IDENTIFIER trim]]()]]
    [IF [BINARY [VARIABLE errors] == [LITERAL 0]]
        [BLOCK
            [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([LITERAL "No errors found! :)"])]]
        ]
    ELSE 
        [BLOCK
            [EXPR_STMT [FUNCTION CALL [VARIABLE write]([FUNCTION CALL [VARIABLE new_line]()])]]
            [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([BINARY [BINARY [LITERAL ":( "] .. [VARIABLE errors]] .. [LITERAL " errors found!"]])]]
        ]
    ]
    [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([LITERAL "-- Finished tests! --"])]]
    [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([BINARY [BINARY [LITERAL "Elapsed time: "] .. [FUNCTION CALL [VARIABLE start_time:[METHOD elapsed]]()]] .. [LITERAL " ms"]])]]
    [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([BINARY [LITERAL "Loaded modules: "] .. [FUNCTION CALL [VARIABLE machine.[IDENTIFIER modules]]()]])]]
]
