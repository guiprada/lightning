[PROGRAM
    [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([LITERAL "*** Welcome to lightning test suite Zzz :) ***"])]]
    [VARIABLE DECLARATION os_string = [FUNCTION CALL [VARIABLE get_os]()]]
    [VARIABLE DECLARATION os = [LITERAL "Unknown"]]
    [IF [FUNCTION CALL [VARIABLE os_string:[METHOD contains]]([LITERAL "Windows"])]
        [EXPR_STMT [ASSIGMENT os = [LITERAL "Windows"]]]
    ELSE 
        [IF [FUNCTION CALL [VARIABLE os_string:[METHOD contains]]([LITERAL "Unix"])]
            [EXPR_STMT [ASSIGMENT os = [LITERAL "Unix"]]]
        ]
    ]
    [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([FUNCTION CALL [VARIABLE get_os]()])]]
    [IF [BINARY [VARIABLE intrinsic.[IDENTIFIER create]] == [LITERAL "Null"]]
        [BLOCK
            [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([LITERAL "No inline intrinsic support!"])]]
        ]
    ]
    [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([LITERAL "-- Starting tests --"])]]
    [VARIABLE DECLARATION start_time = [FUNCTION CALL [VARIABLE time.[IDENTIFIER now]]()]]
    [VARIABLE DECLARATION _assert = [FUNCTION CALL [VARIABLE require]([LITERAL "assert.ltn"])]]
    [VARIABLE DECLARATION assert_counter = [FUNCTION CALL [VARIABLE require]([LITERAL "assert_counter.ltn"])]]
    [VARIABLE DECLARATION assert = [VARIABLE assert_counter.[IDENTIFIER assert]]]
    [VARIABLE DECLARATION assert_not = [VARIABLE assert_counter.[IDENTIFIER assert_not]]]
    [VARIABLE DECLARATION count_errors = [VARIABLE assert_counter.[IDENTIFIER get_error_counter]]]
    [VARIABLE DECLARATION clear_errors = [VARIABLE assert_counter.[IDENTIFIER reset_error_counter]]]
    [VARIABLE DECLARATION errors = [LITERAL 0]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/assert.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/numbers.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/strings.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/pmap.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/rmap.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/map.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/reduce.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/table.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/scoping.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/up_value.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/closures.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/lambdas.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/boolean.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/iterators.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/methods.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/compound_calls.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/transient.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/math.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/eval.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/maybe.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/assign_op.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/lock.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/vm_management.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/inline_intrinsics.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/nuples.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/super_table.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/char.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/integers.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/anonymous_call.ltn"])]]]
    [EXPR_STMT [ASSIGMENT_OP errors += [FUNCTION CALL [VARIABLE require]([LITERAL "tests/try.ltn"])]]]
    [BLOCK
        [VARIABLE DECLARATION a_table = [LIST [LITERAL "value"] : [LITERAL 100], [LITERAL "a_function"] : 
            [FUNCTION EXPRESSION ()
                [RETURN [LITERAL 99]]
            ]]
        [EXPR_STMT [FUNCTION CALL [VARIABLE assert]([FUNCTION CALL [VARIABLE a_table.[IDENTIFIER a_function]]()][LITERAL 99], [LITERAL "Failed Table Map Access By Literal String 2."], )]]
        [VARIABLE DECLARATION name = [LITERAL "a_function"]]
        [EXPR_STMT [FUNCTION CALL [VARIABLE assert]([FUNCTION CALL [VARIABLE a_table[[VAR_EXPRESSION ]]]()][LITERAL 99], [LITERAL "Failed Table Map Access By Literal String 3."], )]]
        [EXPR_STMT [FUNCTION CALL [VARIABLE assert]([FUNCTION CALL [VARIABLE a_table[[VAR_EXPRESSION ]]]()][LITERAL 99], [LITERAL "Failed Table Map Access By Literal String 4."], )]]
        [EXPR_STMT [FUNCTION CALL [VARIABLE assert]([FUNCTION CALL [VARIABLE a_table[[VAR_EXPRESSION ]]]()][LITERAL 99], [LITERAL "Failed Table Map Access By Literal String 4."], )]]
    ]
    [BLOCK
        [FUNCTION DECLARATION make_player ()
            [VARIABLE DECLARATION player = [LIST ]
            [EXPR_STMT [ASSIGMENT player = [LIST ]]
            [EXPR_STMT [ASSIGMENT player = [LITERAL 0]]]
            [EXPR_STMT [ASSIGMENT player = [LITERAL 0]]]
            [EXPR_STMT [ASSIGMENT player = 
                [FUNCTION EXPRESSION (self, x, y)
                    [EXPR_STMT [ASSIGMENT self = [BINARY [VARIABLE self.[IDENTIFIER position].[IDENTIFIER x]] + [VARIABLE x]]]]
                    [EXPR_STMT [ASSIGMENT self = [BINARY [VARIABLE self.[IDENTIFIER position].[IDENTIFIER y]] + [VARIABLE y]]]]
                    [RETURN [VARIABLE self.[IDENTIFIER position]]]
                ]]]
            [EXPR_STMT [ASSIGMENT player = [VARIABLE player.[IDENTIFIER move]]]]
            [RETURN [VARIABLE player]]
        ]
        [VARIABLE DECLARATION p1 = [FUNCTION CALL [VARIABLE make_player]()]]
        [EXPR_STMT [FUNCTION CALL [VARIABLE assert]([FUNCTION CALL [VARIABLE p1:[METHOD move]]([LITERAL 1][LITERAL 0], ).indexedAccess([IDENTIFIER x])][LITERAL 1], [LITERAL "Failed method call test 1."], )]]
        [EXPR_STMT [FUNCTION CALL [VARIABLE assert]([FUNCTION CALL [VARIABLE p1:[METHOD move]]([LITERAL 0][LITERAL 3], ).indexedAccess([IDENTIFIER y])][LITERAL 3], [LITERAL "Failed method call test 2."], )]]
        [VARIABLE DECLARATION name = [LITERAL "move"]]
        [EXPR_STMT [FUNCTION CALL [VARIABLE assert]([FUNCTION CALL [VARIABLE p1[[VAR_EXPRESSION ]]]([VARIABLE p1][LITERAL 0], [LITERAL 3], ).indexedAccess([IDENTIFIER y])][LITERAL 6], [LITERAL "Failed method call test 3."], )]]
        [EXPR_STMT [FUNCTION CALL [VARIABLE assert]([FUNCTION CALL [VARIABLE p1:[METHOD ]]([LITERAL 0][LITERAL 0], ).indexedAccess([IDENTIFIER y])][LITERAL 6], [LITERAL "Failed method call test 4."], )]]
        [EXPR_STMT [FUNCTION CALL [VARIABLE assert]([FUNCTION CALL [VARIABLE p1:[METHOD move]]([LITERAL 0][LITERAL 0], ).indexedAccess([IDENTIFIER y])][LITERAL 6], [LITERAL "Failed method call test 5."], )]]
        [EXPR_STMT [FUNCTION CALL [VARIABLE assert]([FUNCTION CALL [VARIABLE p1[[VAR_EXPRESSION ]]]([VARIABLE p1][LITERAL 0], [LITERAL 0], ).indexedAccess([IDENTIFIER y])][LITERAL 6], [LITERAL "Failed method call test 6."], )]]
        [EXPR_STMT [FUNCTION CALL [VARIABLE assert]([FUNCTION CALL [VARIABLE p1:[METHOD ]]([LITERAL 0][LITERAL 0], ).indexedAccess([IDENTIFIER y])][LITERAL 6], [LITERAL "Failed method call test 7."], )]]
        [EXPR_STMT [FUNCTION CALL [VARIABLE assert]([FUNCTION CALL [VARIABLE p1:[METHOD ]]([LITERAL 0][LITERAL 0], ).indexedAccess([IDENTIFIER y])][LITERAL 6], [LITERAL "Failed method call test 7."], )]]
        [EXPR_STMT [FUNCTION CALL [VARIABLE assert]([FUNCTION CALL [VARIABLE p1:[METHOD ]]([LITERAL 0][LITERAL 0], ).indexedAccess([IDENTIFIER y])][LITERAL 6], [LITERAL "Failed method call test 7."], )]]
    ]
    [EXPR_STMT [FUNCTION CALL [VARIABLE machine.[IDENTIFIER trim]]()]]
    [IF [BINARY [VARIABLE errors] == [LITERAL 0]]
        [BLOCK
            [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([LITERAL "No errors found! :)"])]]
        ]
    ELSE 
        [BLOCK
            [EXPR_STMT [FUNCTION CALL [VARIABLE write]([FUNCTION CALL [VARIABLE new_line]()])]]
            [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([BINARY [BINARY [LITERAL ":( "] .. [VARIABLE errors]] .. [LITERAL " errors found!"]])]]
        ]
    ]
    [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([LITERAL "-- Finished tests! --"])]]
    [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([BINARY [BINARY [LITERAL "Elapsed time: "] .. [FUNCTION CALL [VARIABLE start_time:[METHOD elapsed]]()]] .. [LITERAL " ms"]])]]
    [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([BINARY [LITERAL "Loaded modules: "] .. [FUNCTION CALL [VARIABLE machine.[IDENTIFIER modules]]()]])]]
    [EXPR_STMT [FUNCTION CALL [VARIABLE write_line]([FUNCTION CALL [VARIABLE machine.[IDENTIFIER memory_use]]()])]]
]
